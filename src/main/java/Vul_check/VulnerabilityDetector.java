package Vul_check;
import java.io.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/*
漏洞检测遍历
*/
public class VulnerabilityDetector {
    private List<VulRule> vulrules;

    public void setVulRules(List<VulRule> vulrules) {
        this.vulrules=vulrules;
    }

    public void detect() throws IOException, InterruptedException {
        /*
        * url导入Arraylist
        * */
        String filename= "run   .txt";
        String line;
        final List<String> list = new ArrayList<String>();
        File file =new File(filename);
        FileInputStream fileInputStream = new FileInputStream(file);
        InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream);
        BufferedReader br = new BufferedReader(inputStreamReader);
        while ((line=br.readLine())!=null){
            list.add(line);
        }
        System.out.println("共检测出"+list.size()+"条数据----请设置检测参数:");
        br.close();

        System.out.println("请输入想进行的线程数 :  ");
        Scanner scanner = new Scanner(System.in);
        final int th =scanner.nextInt();

        System.out.println("请输入探测网站的最大响应时间:  ");
        Scanner scanner1 = new Scanner(System.in);
        final int outtime =scanner1.nextInt();

        System.out.println("+++++++++++++++++++++++++++++++++++++++漏洞全方位探测中++++++++++++++++++++++++++++++++++++++++++++++\n" +
                           "   z z z z z z z z                     sss                                      jjj               \n" +
                           "                z                    ss   ss                                    j j               \n" +
                           "              z                    ss       ss                                  j j               \n" +
                           "            z                        ss                                         j j               \n" +
                           "          z          fuck               ss                web                   j j               \n" +
                           "        z                                  ss                           j       j j               \n" +
                           "      z                                      ss                        jjj      j j               \n" +
                           "    z                                ss      ss                        jjjj   j  j                \n" +
                           "  z z z z z z z z z                      sss                            jjjj j j                  \n" +
                           "***********************ZSJ漏洞探测框架_____支持自由编写漏洞拓展生成自己的漏洞数据库**************************\n");
        /*
        * 线程池
        * */
        Thread.sleep(2000);
        int threadsize=th;
        int threadNum= list.size()/threadsize+1;

        //开启文件
        final FileWriter pw = new FileWriter("temp.txt",true);
        // 创建一个线程池
        ExecutorService exec = Executors.newFixedThreadPool(threadNum);
        // 定义一个任务集合
        List<Callable<Integer>> tasks = new ArrayList<Callable<Integer>>();
        Callable<Integer> task = null;
        List<String> cutList = null;
         for (int i=0;i<threadNum;i++){
              if (i==threadNum-1){
                  cutList=list.subList(i*threadsize,list.size());
              }else {
                  cutList=list.subList(i*threadsize,(i+1)*threadsize);
              }
             final List<String> str = cutList;
             task =new Callable<Integer>() {
                 public Integer call() throws Exception {

                     for ( final VulRule vulRule : vulrules) {
                         Thread thread = new Thread(new Runnable() {
                             public void run() {
                                 try {
                                     vulRule.check(th,str,str.size(),outtime);
                                 } catch (IOException e) {
                                     e.printStackTrace();
                                 }
                             }
                         });
                         thread.start();
                         thread.interrupt();
                     }
                     return 1;
                 }
             };

             tasks.add(task);
         }
         exec.invokeAll(tasks);
         exec.shutdown();
         pw.flush();
         pw.close();
     Thread.sleep(10000);
    }
}
